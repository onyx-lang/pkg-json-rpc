package json_rpc

// TODO: eventually delete things marked with :oldcode

use core
use runtime.info

// Public structures

Context :: struct {
    // endpoint.method_name -> endpoint
    endpoint_map: Map(str, Endpoint);
}

Method :: struct {
    name: str;
}

Status :: enum {
    Success;
    Error;
}


// Internal structures

#local
Endpoint :: struct {
    method_name: str;
    param_type: type_expr;
    return_type: type_expr;

    // (^param_type, ^return_type) -> Status
    handler: (rawptr, rawptr) -> Status;
}


// API

handler :: () -> Context {
    s: Context;
    s.endpoint_map = make(typeof s.endpoint_map);

    return s;
}

#inject Context {
    #doc """
        Registers a method on the JSON-RPC Server.
        The parameter and return types are inferred from types on the procedure.
    """
    method :: (hndl: ^Context, method_name: str, handler: any) -> bool {
        handler_info := cast(^Type_Info_Function) get_type_info(handler.type);
        if handler_info.kind != .Function do return false;

        if handler_info.parameter_types.count != 2 do return false;

        param_type_info := cast(^Type_Info_Pointer) get_type_info(handler_info.parameter_types[0]);
        if param_type_info.kind != .Pointer do return false;

        return_type_info := cast(^Type_Info_Pointer) get_type_info(handler_info.parameter_types[1]);
        if return_type_info.kind != .Pointer do return false;

        m := Endpoint.{
            method_name = method_name,
            param_type  = param_type_info.to,
            return_type = return_type_info.to,
            handler     = *cast(^(rawptr, rawptr) -> Status) handler.data
        };

        hndl.endpoint_map[method_name] = m;

        return true;
    }

    #doc """
        Automatically registers all methods defined in the set of packages
        listed in the arguments. If no packages are listed, all methods from all
        packages are registered.
    """
    collect_methods :: (hndl: ^Context, packages: [] package_id) {
        procs := get_procedures_with_tag(Method);

        for ^ procs {
            if packages.count == 0 || array.contains(packages, it.pack) {
                hndl->method(it.tag.name, any.{^it.func, it.type});
            }
        }
    }

    #doc """
        Handles a JSON-RPC request. This is done SYNCHONOUSLY!
    """
    handle :: (hndl: ^Context, request_string: str, response_writer: ^io.Writer) -> bool {
        request, json_err := json.decode_with_error(request_string);
        defer json.free(request);

        request_obj := request.root;
        method := request_obj["method"]->as_str();
        id     := request_obj["id"];

        if json_err->has_error() {
            pos := json_err->position();

            respond_with_error(ERROR_PARSE_ERROR, tprintf("{} at line {}, column {}", json_err->message(), pos.line, pos.column));
        }

        if request_obj["jsonrpc"]->as_str() != "2.0" {
            respond_with_error(ERROR_INVALID_REQUEST, "'jsonrpc' key not found or not equal to '2.0'.");
        }

        if string.empty(method) {
            respond_with_error(ERROR_INVALID_REQUEST, "'method' not specified.");
        }

        endpoint := ^hndl.endpoint_map[method];
        if endpoint == null {
            respond_with_error(ERROR_METHOD_NOT_FOUND, "method not found.");
        }

        params: rawptr = null;
        result: rawptr = null;
        defer if params != null do delete(params);
        defer if result != null do delete(result);

        if !(request_obj["params"]->is_null()) {
            params = new(endpoint.param_type);

            json.to_any(request_obj["params"], endpoint.param_type, params);
        }

        result = new(endpoint.return_type);

        status := endpoint.handler(params, result);

        // If no id was given, no response should be generated.
        if id->is_null() {
            return true;
        }

        json_result := json.null_value();
        if endpoint.return_type != void {
            json_result = json.from_any(endpoint.return_type, result);
        }

        if status == .Success {
            json.encode(response_writer, json.from_any(^.{
                jsonrpc = "2.0",
                result = json_result,
                id = id
            }));

        } else {
            respond_with_error(ERROR_INTERNAL_ERROR, "error processing request");
        }

        return true;

        respond_with_error :: macro (code: i32, message: str) {
            result := .{
                jsonrpc = "2.0",
                error = Error_Status.{ code = code, message = message },
                id = id
            };

            json.encode(response_writer, json.from_any(^result));
            return false;
        }
    }
}

#local
Error_Status :: struct {
    code: i32;
    message: str;
}


#local {
    ERROR_PARSE_ERROR      :: -32700
    ERROR_INVALID_REQUEST  :: -32600
    ERROR_METHOD_NOT_FOUND :: -32601
    ERROR_INVALID_PARAMS   :: -32602
    ERROR_INTERNAL_ERROR   :: -32603
}
