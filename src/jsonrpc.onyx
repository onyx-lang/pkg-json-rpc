package json_rpc

// TODO: eventually delete things marked with :oldcode

use core
use runtime.info

// Public structures

Context :: struct {
    // endpoint.method_name -> endpoint
    endpoint_map: Map(str, Endpoint);

    // :oldcode
    // context.thread_id -> method handle status 
    // methods_being_handled: Map(u32, Method_Handle);
}

Method :: struct {
    name: str;
    // :oldcode
    // return_type: type_expr;
}

Status :: enum {
    Success;
    Error;
}


// Internal structures

#local
Endpoint :: struct {
    method_name: str;
    param_type: type_expr;
    return_type: type_expr;

    // (^Context, ^param_type, ^return_type) -> Status
    handler: (^Context, rawptr, rawptr) -> Status;
}

// :oldcode
// #local
// Method_Handle :: struct {
//     endpoint: ^Endpoint;
//     w: ^io.Writer;
//     id: json.Value;
// 
//     handled := false;
// }



handler :: () -> Context {
    s: Context;
    s.endpoint_map = make(typeof s.endpoint_map);
    // :oldcode
    // s.methods_being_handled = make(typeof s.methods_being_handled);

    return s;
}

#inject Context {
    #doc """
        Registers a method on the JSON-RPC Server.
        The parameter and return types are inferred from types on the procedure.
    """
    method :: (hndl: ^Context, method_name: str, handler: any) -> bool {
        handler_info := cast(^Type_Info_Function) get_type_info(handler.type);
        if handler_info.kind != .Function do return false;

        if handler_info.parameter_types.count != 3 do return false;
        if handler_info.parameter_types[0] != ^Context do return false;

        param_type_info := cast(^Type_Info_Pointer) get_type_info(handler_info.parameter_types[1]);
        if param_type_info.kind != .Pointer do return false;

        return_type_info := cast(^Type_Info_Pointer) get_type_info(handler_info.parameter_types[2]);
        if return_type_info.kind != .Pointer do return false;

        m := Endpoint.{
            method_name = method_name,
            param_type  = param_type_info.to,
            return_type = return_type_info.to,
            handler     = *cast(^(^Context, rawptr, rawptr) -> Status) handler.data
        };

        hndl.endpoint_map[method_name] = m;

        return true;
    }

    #doc """
        Automatically registers all methods defined in the set of packages
        listed in the arguments. If no packages are listed, all methods from all
        packages are registered.
    """
    collect_methods :: (hndl: ^Context, packages: [] package_id) {
        procs := get_procedures_with_tag(Method);

        for ^ procs {
            if packages.count == 0 || array.contains(packages, it.pack) {
                hndl->method(it.tag.name, any.{^it.func, it.type});
            }
        }
    }

    #doc """
        Handles a JSON-RPC request. This is done SYNCHONOUSLY!
    """
    handle :: (hndl: ^Context, request_string: str, response_writer: ^io.Writer) -> bool {
        request, json_err := json.decode_with_error(request_string);
        defer json.free(request);

        if json_err->has_error() {
            pos := json_err->position();

            json.encode(response_writer, json.from_any(^.{
                code = ERROR_PARSE_ERROR,
                message = tprintf("{} at line {}, column {}", json_err->message(), pos.line, pos.column)
            }));
            return false;
        }

        request_obj := request.root;

        if request_obj["jsonrpc"]->as_str() != "2.0" {
            json.encode(response_writer, json.from_any(^.{
                code = ERROR_INVALID_REQUEST,
                message = "'jsonrpc' key not found or not equal to '2.0'."
            }));
            return false;
        }

        method := request_obj["method"]->as_str();
        id     := request_obj["id"];

        if string.empty(method) {
            json.encode(response_writer, json.from_any(^.{
                jsonrpc = "2.0",
                code = ERROR_INVALID_REQUEST,
                message = "'method' not specified."
            }));
            return false;
        }

        endpoint := ^hndl.endpoint_map[method];
        if endpoint == null {
            json.encode(response_writer, json.from_any(^.{
                jsonrpc = "2.0",
                code = ERROR_METHOD_NOT_FOUND,
                message = "method not found."
            }));
            return false;
        }

        params: rawptr = null;
        result: rawptr = null;
        defer if params != null do delete(params);
        defer if result != null do delete(result);

        if !(request_obj["params"]->is_null()) {
            params = new(endpoint.param_type);

            json.to_any(request_obj["params"], endpoint.param_type, params);
        }

        result = new(endpoint.return_type);

        // :oldcode
        // hndl.methods_being_handled[context.thread_id] = .{
        //     endpoint = endpoint,
        //     w = response_writer,
        //     id = id
        // };

        status := endpoint.handler(hndl, params, result);

        // If no id was given, no response should be generated.
        if id->is_null() {
            return true;
        }

        json_result := json.null_value();
        if endpoint.return_type != void {
            json_result = json.from_any(endpoint.return_type, result);
        }
        // if !hndl.methods_being_handled[context.thread_id].handled && !(id->is_null()) {
        if status == .Success {
            json.encode(response_writer, json.from_any(^.{
                jsonrpc = "2.0",
                result = json_result,
                id = id
            }));

        } else {
            json.encode(response_writer, json.from_any(^.{
                jsonrpc = "2.0",
                code = ERROR_INTERNAL_ERROR,
                message = "error processing request",
                id = id
            }));
        }

        // :oldcode
        // hndl.methods_being_handled->delete(context.thread_id);
        return true;
    }

    /*
    // :oldcode
    respond :: (hndl: ^Context, value: any) -> bool {
        method_handle := ^hndl.methods_being_handled[context.thread_id];

        if method_handle.handled do return false;

        // If this procedure was passed a pointer to something
        // (likely due to a programmer's optimization), deference
        // it to get the actual value.
        result := core.misc.any_dereference(value);

        // If we are trying to return the wrong type from what
        // is declared above, error.
        if method_handle.endpoint.return_type != result.type {
            // TODO: Proper error message here?
            return false;
        }

        json_result := json.null_value();
        if method_handle.endpoint.return_type != void {
            json_result = json.from_any(result.type, result.data);
        }

        // If the id given is null, do not respond to the request.
        // In theory, this should never happen as the user-code should
        // know this, but don't take chances.
        if !(method_handle.id->is_null()) {
            json.encode(method_handle.w, json.from_any(^.{
                jsonrpc = "2.0",
                result = json_result,
                id = method_handle.id
            }));
        }

        method_handle.handled = true;

        return true;
    }
    */
}


#local {
    ERROR_PARSE_ERROR      :: -32700
    ERROR_INVALID_REQUEST  :: -32600
    ERROR_METHOD_NOT_FOUND :: -32601
    ERROR_INVALID_PARAMS   :: -32602
    ERROR_INTERNAL_ERROR   :: -32603
}
