package json_rpc

// TODO: eventually delete things marked with :oldcode

use core
use runtime.info

// Public structures

Context :: struct {
    // endpoint.method_name -> endpoint
    endpoint_map: Map(str, Endpoint);

    userdata: rawptr;
    userdata_type: type_expr;

    title: str;
    description: str;
    version: str;
}

Method :: struct {
    name: str;
}

Status :: enum {
    Success;
    Error;
}


// Internal structures

#local
Endpoint :: struct {
    method_name: str;
    param_type: type_expr;
    return_type: type_expr;

    // (^Context, ^param_type, ^return_type) -> Status
    handler: (^Context, rawptr, rawptr) -> Status;
}


// API

handler :: () -> Context {
    s := Context.{};
    s.endpoint_map = make(typeof s.endpoint_map);
    s.userdata = null;
    s.userdata_type = void;

    return s;
}

#inject Context {
    #doc """
        Sets internal user data pointer that can be
        used by method handlers for a variety of purposes.
    """
    set_userdata :: macro (hndl: ^Context, data: ^$T) {
        h := hndl;
        h.userdata = data;
        h.userdata_type = T;
    }

    set_metadata :: (hndl: ^Context, title, description, version: str) {
        hndl.title = title;
        hndl.description = description;
        hndl.version = version;
    }

    #doc """
        Registers a method on the JSON-RPC Server.
        The parameter and return types are inferred from types on the procedure.
    """
    method :: (hndl: ^Context, method_name: str, handler: any) -> bool {
        handler_info := cast(^Type_Info_Function) get_type_info(handler.type);
        if handler_info.kind != .Function do return false;

        if handler_info.parameter_types.count != 3 do return false;
        if handler_info.parameter_types[0] != ^Context do return false;

        param_type_info := cast(^Type_Info_Pointer) get_type_info(handler_info.parameter_types[1]);
        if param_type_info.kind != .Pointer do return false;

        return_type_info := cast(^Type_Info_Pointer) get_type_info(handler_info.parameter_types[2]);
        if return_type_info.kind != .Pointer do return false;

        m := Endpoint.{
            method_name = method_name,
            param_type  = param_type_info.to,
            return_type = return_type_info.to,
            handler     = *cast(^(^Context, rawptr, rawptr) -> Status) handler.data
        };

        hndl.endpoint_map[method_name] = m;

        return true;
    }

    #doc """
        Automatically registers all methods defined in the set of packages
        listed in the arguments. If no packages are listed, all methods from all
        packages are registered.
    """
    collect_methods :: (hndl: ^Context, packages: [] package_id) {
        procs := get_procedures_with_tag(Method);

        for ^ procs {
            if packages.count == 0 || array.contains(packages, it.pack) {
                hndl->method(it.tag.name, any.{^it.func, it.type});
            }
        }
    }

    #doc """
        Handles a JSON-RPC request. This is done SYNCHONOUSLY!
    """
    handle :: (hndl: ^Context, request_string: str, response_writer: ^io.Writer) -> bool {
        request, json_err := json.decode_with_error(request_string);
        defer json.free(request);

        request_obj := request.root;
        method := request_obj["method"]->as_str();
        id     := request_obj["id"];

        if json_err->has_error() {
            pos := json_err->position();

            respond_with_error(ERROR_PARSE_ERROR, tprintf("{} at line {}, column {}", json_err->message(), pos.line, pos.column));
        }

        if request_obj["jsonrpc"]->as_str() != "2.0" {
            respond_with_error(ERROR_INVALID_REQUEST, "'jsonrpc' key not found or not equal to '2.0'.");
        }

        if string.empty(method) {
            respond_with_error(ERROR_INVALID_REQUEST, "'method' not specified.");
        }

        endpoint := ^hndl.endpoint_map[method];
        if endpoint == null {
            respond_with_error(ERROR_METHOD_NOT_FOUND, "method not found.");
        }

        // There is a weird compiler bug (feature?) that causes
        // the params and result delete calls to match a DIFFERENT
        // procedure that cfree, which is what is expected.
        // This causes the wrong memory to be freed and I'm not sure
        // how I made it this far without running into this issue...
        // Work around for right now is to cast the rawptr to ^void.
        params: rawptr = null;
        result: rawptr = null;
        defer if params != null do delete(cast(^void) params);
        defer if result != null do delete(cast(^void) result);

        if !(request_obj["params"]->is_null()) {
            params = new(endpoint.param_type);

            json.to_any(request_obj["params"], endpoint.param_type, params);
        }

        result = new(endpoint.return_type);

        status := endpoint.handler(hndl, params, result);

        // If no id was given, no response should be generated.
        if id->is_null() {
            return true;
        }

        json_result := json.null_value();
        if endpoint.return_type != void {
            json_result = json.from_any(endpoint.return_type, result);
        }

        if status == .Success {
            json.encode(response_writer, json.from_any(^.{
                jsonrpc = "2.0",
                result = json_result,
                id = id
            }));

        } else {
            respond_with_error(ERROR_INTERNAL_ERROR, "error processing request");
        }

        json.free(json_result, context.allocator);
        return true;

        respond_with_error :: macro (code: i32, message: str) {
            result := .{
                jsonrpc = "2.0",
                error = Error_Status.{ code = code, message = message },
                id = id
            };

            json.encode(response_writer, json.from_any(^result));
            return false;
        }
    }
}

#local
Error_Status :: struct {
    code: i32;
    message: str;
}


#local {
    ERROR_PARSE_ERROR      :: -32700
    ERROR_INVALID_REQUEST  :: -32600
    ERROR_METHOD_NOT_FOUND :: -32601
    ERROR_INVALID_PARAMS   :: -32602
    ERROR_INTERNAL_ERROR   :: -32603
}
